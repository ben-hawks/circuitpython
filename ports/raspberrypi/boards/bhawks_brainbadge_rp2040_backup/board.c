// This file is part of the CircuitPython project: https://circuitpython.org
//
// SPDX-FileCopyrightText: Copyright (c) 2021 Scott Shawcroft for Adafruit Industries
//
// SPDX-License-Identifier: MIT

#include "supervisor/board.h"

#include "mpconfigboard.h"
#include "shared-bindings/busio/SPI.h"
#include "shared-bindings/fourwire/FourWire.h"
#include "shared-bindings/microcontroller/Pin.h"
#include "shared-module/displayio/__init__.h"
#include "shared-bindings/board/__init__.h"
#include "supervisor/shared/board.h"
#include "brain-badge-shared.h"

digitalio_digitalinout_obj_t enable_pin_obj;

#define EPD_DISPLAY_WIDTH_PX 296
#define EPD_DISPLAY_HEIGHT_PX 128

#define DELAY 0x80

#define SSD1680_DRIVER_CONTROL 0x01
#define SSD1680_GATE_VOLTAGE 0x03
#define SSD1680_SOURCE_VOLTAGE 0x04
#define SSD1680_PROGOTP_INITIAL 0x08
#define SSD1680_PROGREG_INITIAL 0x09
#define SSD1680_READREG_INITIAL 0x0A
#define SSD1680_BOOST_SOFTSTART 0x0C
#define SSD1680_DEEP_SLEEP 0x10
#define SSD1680_DATA_MODE 0x11
#define SSD1680_SW_RESET 0x12
#define SSD1680_TEMP_CONTROL 0x18
#define SSD1680_TEMP_WRITE 0x1A
#define SSD1680_MASTER_ACTIVATE 0x20
#define SSD1680_DISP_CTRL1 0x21
#define SSD1680_DISP_CTRL2 0x22
#define SSD1680_WRITE_RAM1 0x24
#define SSD1680_WRITE_RAM2 0x26
#define SSD1680_WRITE_VCOM 0x2C
#define SSD1680_READ_OTP 0x2D
#define SSD1680_READ_STATUS 0x2F
#define SSD1680_WRITE_LUT 0x32
#define SSD1680_WRITE_BORDER 0x3C
#define SSD1680_SET_RAMXPOS 0x44
#define SSD1680_SET_RAMYPOS 0x45
#define SSD1680_SET_RAMXCOUNT 0x4E
#define SSD1680_SET_RAMYCOUNT 0x4F

// LUTs for 2.9in SSD1680 Display v2 from waveshare - https://github.com/waveshareteam/e-Paper/blob/master/Arduino/epd2in9_V2/epd2in9_V2.cpp
/*
unsigned char _WF_PARTIAL_2IN9[159] =
{
0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
0x80,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
0x40,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
0x0A,0x0,0x0,0x0,0x0,0x0,0x2,
0x1,0x0,0x0,0x0,0x0,0x0,0x0,
0x1,0x0,0x0,0x0,0x0,0x0,0x0,
0x0,0x0,0x0,0x0,0x0,0x0,0x0,
0x0,0x0,0x0,0x0,0x0,0x0,0x0,
0x0,0x0,0x0,0x0,0x0,0x0,0x0,
0x0,0x0,0x0,0x0,0x0,0x0,0x0,
0x0,0x0,0x0,0x0,0x0,0x0,0x0,
0x0,0x0,0x0,0x0,0x0,0x0,0x0,
0x0,0x0,0x0,0x0,0x0,0x0,0x0,
0x0,0x0,0x0,0x0,0x0,0x0,0x0,
0x0,0x0,0x0,0x0,0x0,0x0,0x0,
0x22,0x22,0x22,0x22,0x22,0x22,0x0,0x0,0x0,
0x22,0x17,0x41,0xB0,0x32,0x36,
};

unsigned char WS_20_30[159] =
{
0x80,	0x66,	0x0,	0x0,	0x0,	0x0,	0x0,	0x0,	0x40,	0x0,	0x0,	0x0,
0x10,	0x66,	0x0,	0x0,	0x0,	0x0,	0x0,	0x0,	0x20,	0x0,	0x0,	0x0,
0x80,	0x66,	0x0,	0x0,	0x0,	0x0,	0x0,	0x0,	0x40,	0x0,	0x0,	0x0,
0x10,	0x66,	0x0,	0x0,	0x0,	0x0,	0x0,	0x0,	0x20,	0x0,	0x0,	0x0,
0x0,	0x0,	0x0,	0x0,	0x0,	0x0,	0x0,	0x0,	0x0,	0x0,	0x0,	0x0,
0x14,	0x8,	0x0,	0x0,	0x0,	0x0,	0x1,
0xA,	0xA,	0x0,	0xA,	0xA,	0x0,	0x1,
0x0,	0x0,	0x0,	0x0,	0x0,	0x0,	0x0,
0x0,	0x0,	0x0,	0x0,	0x0,	0x0,	0x0,
0x0,	0x0,	0x0,	0x0,	0x0,	0x0,	0x0,
0x0,	0x0,	0x0,	0x0,	0x0,	0x0,	0x0,
0x0,	0x0,	0x0,	0x0,	0x0,	0x0,	0x0,
0x0,	0x0,	0x0,	0x0,	0x0,	0x0,	0x0,
0x14,	0x8,	0x0,	0x1,	0x0,	0x0,	0x1,
0x0,	0x0,	0x0,	0x0,	0x0,	0x0,	0x1,
0x0,	0x0,	0x0,	0x0,	0x0,	0x0,	0x0,
0x0,	0x0,	0x0,	0x0,	0x0,	0x0,	0x0,
0x44,	0x44,	0x44,	0x44,	0x44,	0x44,	0x0,	0x0,	0x0,
0x22,	0x17,	0x41,	0x0,	0x32,	0x36
};

unsigned char Gray4[159] =
{
0x00,	0x60,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	//VS L0	 //2.28s
0x20,	0x60,	0x10,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	//VS L1
0x28,	0x60,	0x14,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	//VS L2
0x2A,	0x60,	0x15,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	//VS L3
0x00,	0x90,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	//VS L4
0x00,	0x02,	0x00,	0x05,	0x14,	0x00,	0x00,						//TP, SR, RP of Group0
0x1E,	0x1E,	0x00,	0x00,	0x00,	0x00,	0x01,						//TP, SR, RP of Group1
0x00,	0x02,	0x00,	0x05,	0x14,	0x00,	0x00,						//TP, SR, RP of Group2
0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,						//TP, SR, RP of Group3
0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,						//TP, SR, RP of Group4
0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,						//TP, SR, RP of Group5
0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,						//TP, SR, RP of Group6
0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,						//TP, SR, RP of Group7
0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,						//TP, SR, RP of Group8
0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,						//TP, SR, RP of Group9
0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,						//TP, SR, RP of Group10
0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,						//TP, SR, RP of Group11
0x24,	0x22,	0x22,	0x22,	0x23,	0x32,	0x00,	0x00,	0x00,				//FR, XON
0x22,	0x17,	0x41,	0xAE,	0x32,	0x28,							//EOPT VGH VSH1 VSH2 VSL VCOM
};

unsigned char WF_FULL[159] =
{
0x90,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	//VS L0	1.00S
0x60,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	//VS L1
0x90,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	//VS L2
0x60,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	//VS L3
0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	//VS L4
0x19,	0x19,	0x00,	0x00,	0x00,	0x00,	0x00,						//TP, SR, RP of Group0
0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,						//TP, SR, RP of Group1
0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,						//TP, SR, RP of Group2
0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,						//TP, SR, RP of Group3
0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,						//TP, SR, RP of Group4
0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,						//TP, SR, RP of Group5
0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,						//TP, SR, RP of Group6
0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,						//TP, SR, RP of Group7
0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,						//TP, SR, RP of Group8
0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,						//TP, SR, RP of Group9
0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,						//TP, SR, RP of Group10
0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,						//TP, SR, RP of Group11
0x24,	0x42,	0x22,	0x22,	0x23,	0x32,	0x00,	0x00,	0x00,				//FR, XON
0x22,	0x17,	0x41,	0xAE,	0x32,	0x38,							//EOPT VGH VSH1 VSH2 VSL VCOM
};
*/

// This is an ssd1680 control chip. The display is a 2.9" grayscale EInk.
/* From CircuitPy Adafruit SSD1680 driver for start sequence:
        start_sequence[29] = (width - 1) & 0xFF # 2.9" - 0x27
        start_sequence[30] = ((width - 1) >> 8) & 0xFF # 2.9" - 0x01

	Final Command to set size:
	SSD1680_DRIVER_CONTROL, 3, 0x27, 0x01, 0
*/

// Working Start Sequence from python driver:
/*
Start Sequence:
\x12\x80\x14
\x11\x1\x3
\x3c\x1\x5
\x2c\x1\x36
\x3\x1\x17
\x4\x3\x41\x0\x32
\x4e\x1\x1
\x4f\x2\x0\x0
\x1\x3\x27\x1\x0
\x22\x1\xf4


Start Sequence:
0x12,0x80,0x14,
0x11,0x1,0x3,
0x3c,0x1,0x5,
0x2c,0x1,0x36,
0x3,0x1,0x17,
0x4,0x3,0x41,0x0,0x32,
0x4e,0x1,0x1,
0x4f,0x2,0x0,0x0,
0x1,0x3,0x27,0x1,0x0,
0x22,0x1,0xf4
*/



const uint8_t raw_start_sequence[] = {
    0x12, 0x80, 0x14,
    0x11, 0x1, 0x3,
    0x3c, 0x1, 0x5,
    0x2c, 0x1, 0x36,
    0x3, 0x1, 0x17,
    0x4, 0x3, 0x41, 0x0, 0x32,
    0x4e, 0x1, 0x1,
    0x4f, 0x2, 0x0, 0x0,
    0x1, 0x3, 0x27, 0x1, 0x0,
    0x22, 0x1, 0xf4
};


const uint8_t display_start_sequence[] = {
    SSD1680_SW_RESET, DELAY, 20,  // soft reset & wait 20ms
    SSD1680_DATA_MODE, 1, 0x03, // Ram data entry mode
    SSD1680_WRITE_BORDER, 1, 0x05, // border color

    SSD1680_WRITE_VCOM, 1, 0x36,   // Vcom Voltage
    SSD1680_GATE_VOLTAGE, 1, 0x17, // Set gate voltage
    SSD1680_SOURCE_VOLTAGE, 3, 0x41, 0x00, 0x32,   // Set source voltage

    SSD1680_TEMP_CONTROL, 1, 0x80, // Set temp control to use internal sensor (Stolen from SSD1681 init?)

    SSD1680_SET_RAMXCOUNT, 1, 1,
    SSD1680_SET_RAMYCOUNT, 2, 0, 0,

    SSD1680_DRIVER_CONTROL, 3, 0x27, 0x01, 0,         // Set Display Size
    SSD1680_DISP_CTRL2, 1, 0xF4 // display update mode - Also used in circuitpy library in the update function?
    // **Final init steps I've found**
    // 0xFE via Adafruit_EPD (C++) Library ???
    // SSD1680_DISP_CTRL2, 1, 0xF7 sets to "Update/Refresh Full" via GxEPD2_290_T94.cpp by ZinggJM on Github
    // SSD1680_DISP_CTRL2, 1, 0xFC sets to "Update/Refresh Partial Area" via GxEPD2_290_T94.cpp by ZinggJM on Github (set/toggeled between 0xFC and 0xF7 as needed in that lib, though)
    // SSD1680_DISP_CTRL2, 1, 0xF4 "display update mode" via CircuitPy Adafruit SSD1680 driver
};

const uint8_t display_stop_sequence[] = {
    SSD1680_DEEP_SLEEP, 0x01, DELAY, 100  // Power off
};

const uint8_t refresh_sequence[] = {
    0x20, 0 // ", 0" stolen from sqmfi Watchy/SSD1681?
};

void board_init(void) {
    // Drive the EN_3V3 pin high so the board stays awake on battery power
    enable_pin_obj.base.type = &digitalio_digitalinout_type;
    common_hal_digitalio_digitalinout_construct(&enable_pin_obj, &pin_GPIO10);
    common_hal_digitalio_digitalinout_switch_to_output(&enable_pin_obj, true, DRIVE_MODE_PUSH_PULL);

    // Never reset
    common_hal_digitalio_digitalinout_never_reset(&enable_pin_obj);

    // Set up the SPI object used to control the display
    busio_spi_obj_t *spi = common_hal_board_create_spi(0);
    common_hal_busio_spi_never_reset(spi);

    // Set up the DisplayIO pin object
    fourwire_fourwire_obj_t *bus = &allocate_display_bus()->fourwire_bus;
    bus->base.type = &fourwire_fourwire_type;
    common_hal_fourwire_fourwire_construct(bus,
        spi,
        &pin_GPIO20, // EPD_DC Command or data
        &pin_GPIO17, // EPD_CS Chip select
        &pin_GPIO21, // EPD_RST Reset
        1200000, // Baudrate
        0, // Polarity
        0); // Phase



    // Set up the DisplayIO epaper object
    epaperdisplay_epaperdisplay_obj_t *display = &allocate_display()->epaper_display;
    display->base.type = &epaperdisplay_epaperdisplay_type;

    epaperdisplay_construct_args_t args = EPAPERDISPLAY_CONSTRUCT_ARGS_DEFAULTS;

    // args.display = display;
    args.bus = bus;
    args.start_sequence = raw_start_sequence;
    args.start_sequence_len = sizeof(raw_start_sequence);
    // 0.0, // start up time
    args.stop_sequence = display_stop_sequence;
    args.stop_sequence_len = sizeof(display_stop_sequence);
    args.width = 296;  // width
    args.height = 128;  // height
    args.ram_width = 176;  // ram_width - 250 in circuitpy driver, but claimed 176 in driver IC datasheet?
    args.ram_height = 296;  // ram_height
    args.colstart = 8;  // colstart
    args.rowstart = 0;  // rowstart
    args.rotation = 270;  // rotation
    args.set_column_window_command = 0x44;  // set_column_window_command
    args.set_row_window_command = 0x45;  // set_row_window_command
    args.set_current_column_command = 0x4E;  // set_current_column_command
    args.set_current_row_command = 0x4F;  // set_current_row_command
    args.write_black_ram_command = 0x24;  // write_black_ram_command
    args.black_bits_inverted = false;  // black_bits_inverted
    args.write_color_ram_command = 0x26;  // write_color_ram_command
    args.color_bits_inverted = false;  // color_bits_inverted
    args.highlight_color = 0xFFFFFF;  // highlight_color - 0x000000 originally
    args.refresh_sequence = refresh_sequence;
    args.refresh_sequence_len = sizeof(refresh_sequence);
    args.refresh_time = 1.0;  // refresh_time
    args.busy_pin = &pin_GPIO26;  // busy_pin
    args.busy_state = true;  // busy_state
    args.seconds_per_frame = 4.0; // seconds_per_frame
    args.always_toggle_chip_select = false;  // always_toggle_chip_select
    args.grayscale = false; // grayscale
    args.acep = false; // acep
    args.two_byte_sequence_length = false;  // two_byte_sequence_length
    args.address_little_endian = true; // address_little_endian
    common_hal_epaperdisplay_epaperdisplay_construct(display, &args);

}


void board_deinit(void) {
    epaperdisplay_epaperdisplay_obj_t *display = &displays[0].epaper_display;
    if (display->base.type == &epaperdisplay_epaperdisplay_type) {
        while (common_hal_epaperdisplay_epaperdisplay_get_busy(display)) {
            RUN_BACKGROUND_TASKS;
        }
    }
    common_hal_displayio_release_displays();
}

// Use the MP_WEAK supervisor/shared/board.c versions of routines not defined here.
